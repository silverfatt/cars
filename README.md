# Автопарк

Выполнили студенты группы М8О-108СВ-24 Фаттяхетдинов Сильвестр и Михеева Кристина

## Задание
Разработайте систему обслуживания и администрирования таксопарка.

### Описание задачи
Владельцам таксопарка не позавидуешь. У них большой парк автомобилей разных марок, выпуска пробега, и они закреплены за разными водителями. Иногда за всеми машинами можно не уследить. Но, понимая, что процесс обслуживания автомобилей можно оптимизировать, например заранее узнать, что выйдет из строя, и через какое количество км, они могут построить оптимальный план график всего автопарка и снизить число недовольных клиентов и водителей. Ваша задача помочь в их желании, написав систему аудита автомобилей их пробега, пользовательских рейтингов за поездку, сбора параметров поездки и построением оптимального плана обслуживания автомобилей. Естественно, чтобы строить планы вам необходимо обучить оптимально модели машинного обучения, чтобы предсказывать желаемые величины. Ваша задача делать это максимально хорошо, чтобы минимизировать дополнительные издержки. Реализуйте dashboard с агрегированной информацией по каждому автомобилю и водителю, чтобы видеть кого можно штрафовать за неаккуратную езду!

### Нормальное описание задачи

#### Модели данных

Выдержка из условия:

- Автомобиль
  - Марка
  - Год выпуска
  - Пробег
  - Дата последнего обслуживания
  - Кол-во поездок (?)
- Водитель
  - Имя
  - Автомобиль
  - Стаж вождения
  - Кол-во штрафов
  - Общий рейтинг (среднее за все поездки водителя) (это все генерится, как и весь датасет :)) (это тоже влияет на оценку пассажира)
- Поездка
  - Рейтинг
  - Водитель
  - Дистанция поездки
  - Дата поездки
  - Безопасность (?)
Как хранить в БД

- car
  - id SERIAL
  - brand STRING - дано
  - year INT - дано
  - mileage INT - дано
  - last_maintenance_date DATE - дано
  - recommended_maintenance_date DATE - должны сгенерить при помощи ML
- driver
  - id SERIAL
  - car INT car.id
  - ...
- trip
  - rate INT/LITERAL
  - driver INT driver.id
  - ...

#### Цель

Система аудита, позволяющая построить план обслуживания автомобилей
(когда и какой авто выйдет из строя, (мб приедсказание на примерную дату слде обслуживания) -> какую оценку поставит пассажир (может сломаться авто в пути, рейтинг самого водителя))
Вообще можно добавить безопасность поездки -> рейтинг пассажира (просто складывается из последней даты обслуживания, марки авто, опыта водителя)

#### Задачи

- ML
  - Найти/сгенерировать/найти и дополнить/... датасет
  - Обучить по нему модель
- Back (API)
  - GET /api/v1/drivers/list - список водителей
  - GET /api/v1/drivers/{id} - водитель
  - POST /api/v1/drivers/ - создать водителя
  - DELETE /api/v1/drivers/{id} - удалить водителя
  - GET /api/v1/cars/list - список машин
  - GET /api/v1/cars/{id} - машина
  - POST /api/v1/cars/ - создать машину
  - DELETE /api/v1/cars/{id} - удалить машину
  - GET /api/v1/trips/ - поездки
  - GET /api/v1/trips/{id} - поездка
  - POST /api/v1/trips/ - создать поездку
  - DELETE /api/v1/trips/{id} - удалить поездку
  - GET /api/v1/dashboard - видимо, список водитель-машина-дата планового обслуживания



## Решение задачи

### Стек

- СУБД PostgreSQL
- ЯП - Python
- Бэкенд - FastAPI, Pydantic, Uvicorn
- ML - sklearn, numpy, pandas
- Виртуальные окружения - poetry

### Архитектура

Всё приложение представлено двумя компонентами - бэкенд-сервис и БД PostgreSQL. Клиентская часть отсутствует.

Используемая модель обучается предварительно и подгружается сервисом при запуске.

### Бэкенд

#### Краткое описание

Для ведения БД разработаны 3 CRUD модели для объектов `car`, `driver`, `trip` (автомобиль, водитель и поездка соответственно)

Механизм авторизации реализован самоятоятельно на токенах `jwt`, пароли пользователей хранятся в зашифрованном виде.

В БД созданы 4 таблицы, DDL представлены ниже:

```SQL
CREATE TABLE public.car (
	model varchar NOT NULL,
	year_of_manufacture int2 NOT NULL,
	mileage int4 NOT NULL,
	last_maintenance_date date NOT NULL,
	recommended_maintenance_date date NULL,
	id serial4 NOT NULL,
	CONSTRAINT car_pk PRIMARY KEY (id)
);
CREATE TABLE public.driver (
	id serial4 NOT NULL,
	"name" varchar NOT NULL,
	experience_years int2 NOT NULL,
	car_id int4 NOT NULL,
	violations int4 NULL DEFAULT 0,
	CONSTRAINT driver_pkey PRIMARY KEY (id),
	CONSTRAINT fk_car FOREIGN KEY (car_id) REFERENCES public.car(id) ON DELETE CASCADE
);
CREATE TABLE public.trip (
	id serial4 NOT NULL,
	trip_date date NOT NULL,
	distance_km float4 NOT NULL,
	rating int2 NULL,
	"cost" numeric(10, 2) NOT NULL,
	driver_id int4 NOT NULL,
	CONSTRAINT trip_pkey PRIMARY KEY (id),
	CONSTRAINT trip_rating_check CHECK (((rating >= 1) AND (rating <= 5))),
	CONSTRAINT fk_driver FOREIGN KEY (driver_id) REFERENCES public.driver(id) ON DELETE CASCADE
);
CREATE TABLE public.users (
	id serial4 NOT NULL,
	hashed_password varchar NOT NULL,
	email varchar NOT NULL,
	phone varchar NOT NULL,
	initials varchar NOT NULL,
	"position" varchar NOT NULL,
	CONSTRAINT users_pkey PRIMARY KEY (id)
);
```

Полную openapi спецификацию можно найти в корне репозитория в файле `openapi.json`

Для предсказывания рекомендованного времени обслуживания используется метод `/api/v1/dashboards/predict`. Если время обслуживания уже есть в базе и оно не просрочено - оно отдаётся пользователю. В противном случае время предсказывается при помощи модели, обновляется запись в БД и отдаётся пользователю.

#### Варианты развития

- Добавить поддержку TLS
- Добавить контейнеризацию
- Заменить собственные методы авторизации на использование готовых провайдеров, например,`Keycloak`.
- Совершенствование алгоритмов прогнозирования

#### Запуск проекта

- poetry install
- poetry run python src
